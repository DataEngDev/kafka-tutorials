////
In this file you describe the Kafka streams topology, and should cover the main points of the tutorial.
The text assumes a method buildTopology exists and constructs the Kafka Streams application.  Feel free to modify the text below to suit your needs.
////

Here is the code we'll use to drive our tutorial

[source, java]
----

    builder.stream(inputTopic, Consumed.with(Serdes.String(), Serdes.String()))
                .mapValues(value -> value.substring(0, value.indexOf('X'))) <1>
                .to(outputTopic, Produced.with(Serdes.String(), Serdes.String()));

    KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), envProps);
    final MaxFailuresUncaughtExceptionHandler exceptionHandler = new MaxFailuresUncaughtExceptionHandler(maxFailures, maxTimeInterval);  <2>
    kafkaStreams.setUncaughtExceptionHandler(exceptionHandler); <3>


----

<1> Here's some suspicious code, if there's no 'X' in the value we'll get an exception!
<2> Instantiating the exception handler, the maxFailures (3) and maxTimeInterval (5000 ms) variables get their values from the configuration files
<3> Adding the handler to Kafka Streams

From looking at the code above, you can see it assumes there's always an 'X' character contained in the value.  But if there isn't, the `value.indexOf` method throws an exception, and the `StreamsUncaughtException` handler comes into play.  If there more than 3 errors within 5 seconds, the application will shut down.  But for the first two execeptions, we'll replace the thread and keep running.


Now create the following file at `src/main/java/io/confluent/developer/StreamsUncaughtExceptionHandling.java`

+++++
<pre class="snippet"><code class="java">{% include_raw tutorials/error-handling/kstreams/code/src/main/java/io/confluent/developer/StreamsUncaughtExceptionHandling.java %}</code></pre>
+++++
